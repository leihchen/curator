CREATE TABLE IF NOT EXISTS public.logs_0
(
  report_period_start timestamp with time zone,
  report_period_end timestamp with time zone,
  interval_start timestamp with time zone,
  interval_end timestamp with time zone,
  namespace text,
  namespace_labels text
) PARTITION BY RANGE (report_period_start);
    
CREATE TABLE IF NOT EXISTS public.logs_1
(
  report_period_start timestamp with time zone,
  report_period_end timestamp with time zone,
  interval_start timestamp with time zone,
  interval_end timestamp with time zone,
  node text,
  node_labels text
) PARTITION BY RANGE (report_period_start);

CREATE TABLE IF NOT EXISTS public.logs_2
(
  report_period_start timestamp with time zone,
	report_period_end timestamp with time zone,
	interval_start timestamp with time zone,
	interval_end timestamp with time zone,
	node text,
	namespace text,
	pod text,
	pod_usage_cpu_core_seconds double precision,
	pod_request_cpu_core_seconds double precision,
	pod_limit_cpu_core_seconds double precision,
	pod_usage_memory_byte_seconds double precision,
	pod_request_memory_byte_seconds double precision,
	pod_limit_memory_byte_seconds double precision,
	node_capacity_cpu_cores double precision,
	node_capacity_cpu_core_seconds double precision,
	node_capacity_memory_bytes double precision,
	node_capacity_memory_byte_seconds double precision,
	resource_id text,
	pod_labels text
) PARTITION BY RANGE (report_period_start);

CREATE TABLE IF NOT EXISTS public.logs_3
(
  report_period_start timestamp with time zone,
	report_period_end timestamp with time zone,
	interval_start timestamp with time zone,
	interval_end timestamp with time zone,
	namespace text,
	pod text,
	persistentvolumeclaim text,
	persistentvolume text,
	storageclass text,
	persistentvolumeclaim_capacity_bytes double precision,
	persistentvolumeclaim_capacity_byte_seconds double precision,
	volume_request_storage_byte_seconds double precision,
	persistentvolumeclaim_usage_byte_seconds double precision,
	persistentvolume_labels text,
	persistentvolumeclaim_labels text
) PARTITION BY RANGE (report_period_start);

CREATE TABLE IF NOT EXISTS public.history
(
  file_names text,
  manifest jsonb,
  success boolean,
  crtime timestamp with time zone
) PARTITION BY RANGE (crtime);

CREATE TABLE IF NOT EXISTS public.reports
(
  frequency text,
  interval_start text,
  pod_usage_cpu_core_seconds double precision,
  pod_request_cpu_core_seconds double precision,
  pod_limit_cpu_core_seconds double precision,
  pod_usage_memory_byte_seconds double precision,
  pod_request_memory_byte_seconds double precision,
  pod_limit_memory_byte_seconds double precision,
  node_capacity_cpu_cores double precision,
  node_capacity_cpu_core_seconds double precision,
  node_capacity_memory_bytes double precision,
  node_capacity_memory_byte_seconds double precision,
  namespace text
);

CREATE TABLE IF NOT EXISTS public.reports_human(
          frequency text ,
          interval_start timestamp with time zone,
          interval_end timestamp with time zone,
          namespace text,
          "pods_avg_usage_cpu_core_total[millicore]" double precision,
          "pods_request_cpu_core_total[millicore]" double precision,
          "pods_limit_cpu_core_total[millicore]" double precision,
          "pods_avg_usage_memory_total[mb]" double precision,
          "pods_request_memory_total[mb]" double precision,
          "pods_limit_memory_total[mb]" double precision
) PARTITION BY RANGE (interval_start);

SELECT partman.create_parent( p_parent_table => 'public.logs_0',
 p_control => 'report_period_start',
 p_type => 'native',
 p_interval=> 'daily');

SELECT partman.create_parent( p_parent_table => 'public.logs_1',
 p_control => 'report_period_start',
 p_type => 'native',
 p_interval=> 'daily');

SELECT partman.create_parent( p_parent_table => 'public.logs_2',
 p_control => 'report_period_start',
 p_type => 'native',
 p_interval=> 'daily');

SELECT partman.create_parent( p_parent_table => 'public.logs_3',
 p_control => 'report_period_start',
 p_type => 'native',
 p_interval=> 'daily');

SELECT partman.create_parent( p_parent_table => 'public.history',
 p_control => 'crtime',
 p_type => 'native',
 p_interval=> 'daily');

SELECT partman.create_parent( p_parent_table => 'public.reports_human',
 p_control => 'interval_start',
 p_type => 'native',
 p_interval=> 'daily');

UPDATE partman.part_config
SET infinite_time_partitions = true,
    retention = '1 day',
    retention_keep_table=true
WHERE parent_table IN ('public.logs_0', 'public.logs_1', 'public.logs_2', 'public.logs_3', 'public.history', 'public.reports_human');

